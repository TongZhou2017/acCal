name: 自动发布会议

on:
  pull_request:
    types: [closed]

jobs:
  publish_conference:
    # 仅处理合并到 main 分支的 PR
    if: github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'main'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: 检查代码
        uses: actions/checkout@v4
        with:
          ref: main
          fetch-depth: 0  # 获取完整历史，以便访问 PR base 和 merge SHA
      
      - name: 查找新添加的会议文件
        id: find_conferences
        run: |
          # 获取 PR 中修改的文件
          BASE_SHA="${{ github.event.pull_request.base.sha }}"
          MERGE_SHA="${{ github.event.pull_request.merge_commit_sha }}"
          
          echo "PR Base SHA: $BASE_SHA"
          echo "PR Merge SHA: $MERGE_SHA"
          echo "当前 HEAD: $(git rev-parse HEAD)"
          
          # 确保 SHA 存在
          if ! git cat-file -e "$BASE_SHA" 2>/dev/null; then
            echo "⚠️ Base SHA 不存在，尝试获取..."
            git fetch origin "$BASE_SHA" 2>&1 || echo "无法获取 Base SHA"
          fi
          
          if ! git cat-file -e "$MERGE_SHA" 2>/dev/null; then
            echo "⚠️ Merge SHA 不存在，尝试获取..."
            git fetch origin "$MERGE_SHA" 2>&1 || echo "无法获取 Merge SHA"
          fi
          
          # 尝试多种方法获取 PR 中新增或修改的文件
          PR_FILES=""
          
          # 方法1: 使用 PR base 和 merge SHA
          if git cat-file -e "$BASE_SHA" 2>/dev/null && git cat-file -e "$MERGE_SHA" 2>/dev/null; then
            echo "✅ 使用 PR base 和 merge SHA 获取文件列表"
            PR_FILES=$(git diff --name-only --diff-filter=AM "$BASE_SHA" "$MERGE_SHA" 2>&1)
            if [ $? -eq 0 ] && [ -n "$PR_FILES" ]; then
              echo "成功获取文件列表"
            else
              echo "方法1失败，尝试其他方法..."
              PR_FILES=""
            fi
          fi
          
          # 方法2: 如果方法1失败，使用 HEAD 和 HEAD~1（合并后的最新提交）
          if [ -z "$PR_FILES" ]; then
            echo "尝试使用 HEAD 和 HEAD~1"
            if git rev-parse HEAD~1 >/dev/null 2>&1; then
              PR_FILES=$(git diff --name-only --diff-filter=AM HEAD~1 HEAD 2>&1)
              if [ $? -eq 0 ] && [ -n "$PR_FILES" ]; then
                echo "✅ 使用 HEAD~1 和 HEAD 成功获取文件列表"
              else
                PR_FILES=""
              fi
            fi
          fi
          
          # 方法3: 如果前两种方法都失败，使用 GitHub API 获取文件列表
          if [ -z "$PR_FILES" ]; then
            echo "尝试使用 GitHub API 获取文件列表"
            PR_NUMBER="${{ github.event.pull_request.number }}"
            PR_FILES=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/${{ github.repository }}/pulls/$PR_NUMBER/files" | \
              jq -r '.[] | select(.status == "added" or .status == "modified") | .filename' 2>/dev/null || echo "")
            if [ -n "$PR_FILES" ]; then
              echo "✅ 使用 GitHub API 成功获取文件列表"
            fi
          fi
          
          echo "PR 中修改的文件:"
          echo "$PR_FILES"
          
          CONFERENCE_FILES=""
          if [ -n "$PR_FILES" ]; then
            # 处理文件列表（可能包含换行符）
            while IFS= read -r file || [ -n "$file" ]; do
              # 跳过空行
              [ -z "$file" ] && continue
              # 使用更灵活的匹配模式
              if [[ "$file" == _conferences/*.md ]] || [[ "$file" =~ ^_conferences/.*\.md$ ]]; then
                CONFERENCE_FILES="$CONFERENCE_FILES $file"
              fi
            done <<< "$PR_FILES"
          fi
          
          if [ -z "$CONFERENCE_FILES" ]; then
            echo "found=false" >> $GITHUB_OUTPUT
            echo "⚠️ 没有找到新的会议文件"
            # 尝试查找所有 _conferences 目录下的文件
            echo "检查 _conferences 目录下的所有文件:"
            ls -la _conferences/ || echo "目录不存在"
          else
            echo "found=true" >> $GITHUB_OUTPUT
            echo "files<<EOF" >> $GITHUB_OUTPUT
            echo "$CONFERENCE_FILES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "✅ 找到会议文件: $CONFERENCE_FILES"
          fi
      
      - name: 自动将 draft 改为 false
        if: steps.find_conferences.outputs.found == 'true'
        id: update_draft
        run: |
          FILES="${{ steps.find_conferences.outputs.files }}"
          CHANGED=false
          
          for file in $FILES; do
            file=$(echo "$file" | xargs)  # 去除空格
            if [ -f "$file" ]; then
              echo "📝 处理文件: $file"
              
              # 检查当前 draft 状态
              if grep -q "^draft: true" "$file"; then
                echo "  当前状态: draft: true"
                # 使用 sed 将 draft: true 改为 draft: false
                sed -i 's/^draft: true$/draft: false/' "$file"
                echo "  ✅ 已将 draft 设置为 false"
                CHANGED=true
              elif grep -q "^draft: false" "$file"; then
                echo "  ℹ️  已经是 draft: false，跳过"
              else
                echo "  ⚠️  未找到 draft 字段，添加 draft: false"
                # 在 front matter 中添加 draft: false
                sed -i '/^---$/a draft: false' "$file" | head -1
                CHANGED=true
              fi
              
              # 显示修改后的内容（前20行）
              echo "  文件内容预览:"
              head -20 "$file" | grep -E "(draft:|title:)" || echo "  (未找到相关字段)"
            else
              echo "⚠️  文件不存在: $file"
            fi
          done
          
          if [ "$CHANGED" = "true" ]; then
            echo "changed=true" >> $GITHUB_OUTPUT
          else
            echo "changed=false" >> $GITHUB_OUTPUT
          fi
      
      - name: 提交更改
        if: steps.find_conferences.outputs.found == 'true' && steps.update_draft.outputs.changed == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          
          # 添加所有修改的会议文件
          FILES="${{ steps.find_conferences.outputs.files }}"
          for file in $FILES; do
            file=$(echo "$file" | xargs)
            if [ -f "$file" ]; then
              git add "$file"
            fi
          done
          
          # 检查是否有更改需要提交
          if git diff --staged --quiet; then
            echo "ℹ️  没有需要提交的更改"
          else
            git commit -m "chore: 自动发布会议 (来自 PR #${{ github.event.pull_request.number }})"
            git push
            echo "✅ 已提交并推送更改"
          fi
      
      - name: 删除 PR 分支
        run: |
          PR_BRANCH="${{ github.event.pull_request.head.ref }}"
          echo "准备删除分支: $PR_BRANCH"
          
          # 检查分支名称是否匹配 issue-pr-* 模式（避免误删其他分支）
          if [[ "$PR_BRANCH" =~ ^issue-pr-[0-9]+$ ]]; then
            echo "✅ 确认是自动创建的 PR 分支，准备删除"
            
            # 使用 GitHub API 删除分支（更可靠）
            RESPONSE=$(curl -s -w "\n%{http_code}" -X DELETE \
              -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
              -H "Accept: application/vnd.github.v3+json" \
              "https://api.github.com/repos/${{ github.repository }}/git/refs/heads/$PR_BRANCH")
            
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            BODY=$(echo "$RESPONSE" | sed '$d')
            
            if [ "$HTTP_CODE" = "204" ] || [ "$HTTP_CODE" = "404" ]; then
              echo "✅ 分支 $PR_BRANCH 已删除（HTTP $HTTP_CODE）"
            else
              echo "⚠️  删除分支失败，HTTP 状态码: $HTTP_CODE"
              echo "响应: $BODY"
              # 尝试使用 git push 删除（备用方法）
              echo "尝试使用 git push 删除..."
              git push origin --delete "$PR_BRANCH" 2>&1 || echo "git push 删除也失败"
            fi
          else
            echo "ℹ️  跳过删除非自动创建的分支: $PR_BRANCH"
            echo "（仅删除 issue-pr-* 格式的分支）"
          fi

